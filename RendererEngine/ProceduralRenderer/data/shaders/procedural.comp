#version 460
#extension GL_GOOGLE_include_directive : require

#include "noise.h"

layout (local_size_x = 16, local_size_y = 16) in;

layout(set = 0, binding = 0, rgba8) uniform writeonly image2D outputImage;
layout(set = 0, binding = 1) uniform CameraProperty { 
	mat4 view;
	mat4 proj;
	mat4 viewInverse;
	mat4 projInverse;
} cam;

layout(push_constant) uniform Params {
	uint width;
	uint height;
	float timeElapsed;
} params;

struct Ray {
	vec3 origin;
	vec3 direction;
};

const float pi = 3.14159;

Ray generateRayForPixel(uint x, uint y)
{
	const vec2 subpixelJitter = vec2(0);
	const vec2 pixelPos = gl_GlobalInvocationID.xy;
	const vec2 pixelDim = vec2(params.width, params.height);
	const vec2 texcoord = (pixelPos + subpixelJitter) / pixelDim;
	const vec2 screenPos = texcoord * 2.0 - 1.0;
	const vec4 camPos    = cam.viewInverse * vec4(0, 0, 0, 1);
	const vec4 camTarget = cam.projInverse * vec4(screenPos.x, screenPos.y, 1, 1);
	const vec4 camDir    = cam.viewInverse * vec4(normalize(camTarget.xyz), 0);
	Ray ray;
	ray.origin = camPos.xyz;
	ray.direction = camDir.xyz;
	return ray;
}

float height(float x, float z)
{
#if 0
	return -2;
#elif 0
	return sin(x) * sin(z) - 2;
#else
	return cnoise(vec3(x, z, 0/*params.timeElapsed*/)) + 1.0 * 0.5;
#endif
}
// Central difference
vec3 getNormal(vec3 p)
{
	const float eps = 0.01f;
	return normalize(
		vec3(
			height(p.x - eps, p.z) - height(p.x + eps, p.z),
			2.0f*eps,
			height(p.x, p.z - eps) - height(p.x, p.z + eps)
		)
	);
}
// https://www.iquilezles.org/www/articles/terrainmarching/terrainmarching.htm
bool castRay(in Ray ray, out float dist)
{
	const float dt = 0.1f;
	const float mint = 0.001f;
	const float maxt = 100.0f;
	float lh = 0.0f;
	float ly = 0.0f;
	for(float t = mint; t < maxt; t += dt)
	{
		const vec3 stepPos = ray.origin + ray.direction * t;
		float h = height(stepPos.x, stepPos.z);
		if(stepPos.y < h)
		{
			// interpolate the intersection distance
			dist = t - dt + dt*(lh-ly)/(stepPos.y-ly-h+lh);
			return true;
		}
		// allow the error to be proportinal to the distance
		//dt = 0.01f*t;
		lh = h;
		ly = stepPos.y;
	}
	return false;
}

vec4 terrainColor(in Ray ray, in float t)
{
	vec3 hitPoint = ray.origin + ray.direction * t;
	return vec4(1) * dot(getNormal(hitPoint), vec3(0, 1, 0));
}

vec4 skyColor()
{
	return vec4(0.5, 0.5, 1, 1);
}

// TODO map space bar to shader reloading.
void main()
{
	Ray ray = generateRayForPixel(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
	
	vec4 outputColor;
	float t;
	if(castRay(ray, t)) 
	{
		outputColor = terrainColor(ray, t);
	}
	else
	{
		outputColor = skyColor();
	}
#if 1
	imageStore(
		outputImage,
		ivec2(gl_GlobalInvocationID.xy),
		outputColor
	);
#elif 1
	if(dot(ray.direction, vec3(0, 1, 0)) > 0.0)
	{
		imageStore(
			outputImage,
			ivec2(gl_GlobalInvocationID.xy),
			vec4(vec3(0), 1)
			//vec4(ray.direction, 1)//outColor
		);
	}
	else
	{
		imageStore(
			outputImage,
			ivec2(gl_GlobalInvocationID.xy),
			vec4(vec3(1), 1)//outColor
		);
	}
#else
	imageStore(
		outputImage,
		ivec2(gl_GlobalInvocationID.xy),
		vec4(ray.direction, 1)//outColor
	);
#endif
}
