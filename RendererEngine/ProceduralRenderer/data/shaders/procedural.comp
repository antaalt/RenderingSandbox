#version 460
#extension GL_GOOGLE_include_directive : require

#include "noise.h"

layout (local_size_x = 16, local_size_y = 16) in;

layout(set = 0, binding = 0, rgba8) uniform image2D outputImage;
layout(set = 0, binding = 1) uniform CameraProperty { 
	mat4 view;
	mat4 proj;
	mat4 viewInverse;
	mat4 projInverse;
} cam;

layout(push_constant) uniform Params {
	uint samples;
	uint width;
	uint height;
	float timeElapsed;
} params;

struct Ray {
	vec3 origin;
	vec3 direction;
};

const float pi = 3.14159;

// TODO 
// - Add reflection path tracing (as raymarching.)
// - Control octave with ImGui
// - Better camera movement
// -
// https://wangyasai.github.io/Perlin-Noise/
// https://gpfault.net/posts/perlin-noise.txt.html
// https://www.iquilezles.org/www/articles/terrainmarching/terrainmarching.htm
// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83
// https://computergraphics.stackexchange.com/questions/161/what-is-ray-marching-is-sphere-tracing-the-same-thing

Ray generateRayForPixel(uint x, uint y)
{
	uint seed = genFirstSeed(x, y + params.samples);
	const vec2 subpixelJitter = vec2(rnd(seed), rnd(seed));// vec2(noise(vec2(x, y + params.samples)) - 0.5, noise(vec2(y, x+ params.samples)) - 0.5);
	const vec2 pixelPos = gl_GlobalInvocationID.xy;
	const vec2 pixelDim = vec2(params.width, params.height);
	const vec2 texcoord = (pixelPos + subpixelJitter) / pixelDim;
	const vec2 screenPos = texcoord * 2.0 - 1.0;
	const vec4 camPos    = cam.viewInverse * vec4(0, 0, 0, 1);
	const vec4 camTarget = cam.projInverse * vec4(screenPos.x, screenPos.y, 1, 1);
	const vec4 camDir    = cam.viewInverse * vec4(normalize(camTarget.xyz), 0);
	Ray ray;
	ray.origin = camPos.xyz;
	ray.direction = camDir.xyz;
	return ray;
}

float height(float x, float z)
{
	// First octave
	const float freq1 = 100;
	const float amp1 = 50.0;
	const float octave1 = noise(vec2(x, z) / freq1) * amp1;
	
	// Second octave
	const float freq2 = 0.5;
	const float amp2 = 0.1;
	const float octave2 = noise(vec2(x, z) / freq2) * amp2;
	
	// Third octave
	const float freq3 = 20;
	const float amp3 = 2.0;
	const float octave3 = noise(vec2(x, z) / freq3) * amp3;
	
	return max(octave1 + octave2 * octave1 / amp1 + octave3 + 10, 0);
}
// Central difference
vec3 getNormal(vec3 p)
{
	const float eps = 0.01f;
	return normalize(
		vec3(
			height(p.x - eps, p.z) - height(p.x + eps, p.z),
			2.0f*eps,
			height(p.x, p.z - eps) - height(p.x, p.z + eps)
		)
	);
}
bool castRay(in Ray ray, out float dist)
{
	const float dt = 1.0f;
	const float mint = 0.001f;
	const float maxt = 1000.0f;
	float lh = 0.0f;
	float ly = 0.0f;
	float ld = 0.0f;
	for(float t = mint; t < maxt;)
	{
		const vec3 stepPos = ray.origin + ray.direction * t;
		const float h = height(stepPos.x, stepPos.z);
		const float delta = max(h, dt);
		if(stepPos.y < h)
		{
			// interpolate the intersection distance
			dist = t - ld + ld*(lh-ly)/(stepPos.y-ly-h+lh);
			return true;
		}
		t += delta;
		ld = delta;
		lh = h;
		ly = stepPos.y;
	}
	return false;
}

vec4 terrainColor(in Ray ray, in float t)
{
	const vec3 hitPoint = ray.origin + ray.direction * t;

	const vec4 colorWater = vec4(0.17, 0.61, 0.83, 1);
	const vec4 colorCliff = vec4(0.17, 0.63, 0.31, 1.0);
	const vec4 colorEdges = vec4(1, 1, 1, 1);
	
	float limit = noise(vec2(hitPoint.x, hitPoint.z) / 0.5);
	
	vec4 color;
	if(hitPoint.y < 0.01)
	{
		color = colorWater;
	}
#if 0
	else
	{
		color = mix(colorCliff, colorEdges, limit);
	}
#else
	else if(hitPoint.y < limit * 10 + 10) // noisy transition
	{
		color = colorCliff;
	}
	else 
	{
		color = colorEdges;
	}
#endif
	const vec3 normal = getNormal(hitPoint);
	const vec3 lightDir = -ray.direction;
	return color * dot(normal, lightDir);
}

vec4 skyColor(in Ray ray)
{
	const vec4 upSky = vec4(0.09, 0.51, 1.0, 1);
	const vec4 downSky = vec4(0.38, 0.75, 1.0, 1);
	return mix(downSky, upSky, dot(ray.direction, vec3(0, 1, 0)));
}

void main()
{
	Ray ray = generateRayForPixel(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
	
	vec4 outputColor;
	float t;
	if(castRay(ray, t)) 
	{
		outputColor = terrainColor(ray, t);
	}
	else
	{
		outputColor = skyColor(ray);
	}
	if(params.samples == 0)
	{
		imageStore(
			outputImage,
			ivec2(gl_GlobalInvocationID.xy),
			outputColor
		);
	}
	else
	{
		imageStore(
			outputImage,
			ivec2(gl_GlobalInvocationID.xy),
			mix(imageLoad(outputImage, ivec2(gl_GlobalInvocationID.xy)), outputColor, 1.f / (params.samples + 1.f))
		);
	}
}
